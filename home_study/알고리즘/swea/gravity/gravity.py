'''
SWEA solving club. 그래비티

문제 분석 및 How?
가로 N, 세로 100 (고정) / 가장 큰 낙차 구하기
'상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며'
-> 2차원 배열 쓰면 될듯 ??

1. 일단 0으로 이루어진 빈 배열을 만든 후, 거기에 쌓여있는 상자의 수 리스트를 추가.
-> 쌓여있는 상자 수는 1로 표시하도록 하자.
2. 모든 행렬을 순회하면서 현재 위치의 오른쪽 값을 확인해본다. 
-> 오른쪽 값이 0이면 낙차가 발생하므로 count 에 1씩 추가하는 방식으로 구현해본다.
'''

'''
한글 코딩
1. 테스트케이스 입력받기
2. 테스트케이스만큼 순회하기
    3. 방의 가로길이 = N 을 입력받기
    4. 쌓여있는 상자의 수를 리스트형태로 입력받기 ( 상자의 수는 곧 열의 높이)

    5. '0' 으로 이루어진 N x 100 행렬을 만든다.
    6. 행렬에 4.번의 리스트를 추가한다. (1의 형태로)
    7. 최대 낙차를 저장할 변수를 만들고 0으로 초기화한다.

    8. 행을 순회하면서
        9. 열을 순회하기
            10. 만약에 현재 위치의 값이 1일 경우:
                11. 낙차값을 카운팅할 변수만들기
                    12. 현재위치의 오른쪽을 순회하면서 확인하기: #범위설정을 어떻게 할까
                        13. 만약에 오른쪽의 값이 0일 경우:
                            14. 11번 변수에 1씩 카운팅함
                
            15. 만약에 최대 낙차 변수의 값보다 카운팅한 변수의 값이 클 경우 
                16. 그 값이 최대 낙차의 값이 된다.

    
    17. 최대 낙차값 출력

'''
import sys
sys.stdin = open("input.txt", "r")


T = int(input())
for tc in range(1, T+1):
    N = int(input())
    li_box = list(map(int,input().split()))

    arr = [[0]*N for _ in range(100)] 
    
    for j in range(N):
        for i in range(100-li_box[j], 100): 
            arr[i][j] = 1

    max_value = 0

    for i in range(100):
        for j in range(N):
            if arr[i][j] == 1:
                count = 0
                for k in range(j+1, N):
                    if arr[i][k] == 0:
                        count += 1
            
                if max_value < count:
                    max_value = count
    print(f'#{tc} {max_value}')
    
    



